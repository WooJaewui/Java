# instanceof 연산자

instanceof 		참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 불가능하면 false를 반환한다.
				형변환 전에 반드시 instanceof로 확인해야된다.
				자식 class에서 조상 class tpye으로 형변환은 항상 true가 나온다.
				
ex) if(a instanceof Tv){			a = 객체. Tv = 클래스.
		Tv c = (Tv)a;				가능.
	}


# 다형성의 장점.

1. 다형적 매개변수.
2. 하나의 배열로 여러종류 객체 다루기.


# 다형성 간단정리.

1. Tv t = new SmartTv();		
2. 참조변수의 형변환. 				사용가능한 멤버 갯수로 형변환
3. instanceof 연산자. 			형변환 가능여부체크


# 매개변수의 다형성.

참조형 매개변수는 메소드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
자식의 참조변수에 부모의 값을 넣을 수 있다.

ex) void method (parents p){
		...
	}
	cla.method(new child);
	
실행 클래스에서 따로초기화 하지 않아서 실행 클래스에서는 사용하지 못하고, 
자식 클래스에서는 매개변수를 통해 조상의 객체를 대입해서 사용할 수 있다.


# 매개변수의 다형성 정리.

1. 부모클래스, 자식클래스, 다형성매개변수클래스, 실행클래스.
2. 부모클래스에 생성자를 통해 자식클래스 변수를 입력받는다. super();
3. 자식클래스는 생성자를 통해 부모클래스에게 자신의 data를 보내준다.
4. 다형성매개변수 메소드에 매개변수로 부모클래스 참조변수를 받는다.
5. 실행클래스는 다형성매개변수클래스를 생성하고 다형성매개변수메소드에 argument로 자식 인스턴스객체를 넣는다.

매개변수로 부모클래스타입에 참조변수로 받고, 인자로 자식인스턴스를 받는다.
상속관계에 있는 클래스들의 같은 변수값을 상황에 맞게 쉽게 조절 할 수 있도록 도와준다.
다형성메소드에 매개변수로 부모클래스 참조변수를 넣었기 때문에 변수값을 조정할 수 있는 메소드는 부모클래스에서 만든다.


# 여러 종류의 객체를 배열로 다루기.

조상타입의 배열에 자손들의 객체를 담을 수 있다.

ex) Product P[] = new Product[3];		일반적인 클래스배열.

	P[0] = new Computer();				부모배열에 자식인스턴스를 대입한다.
	P[1] = new Tv();
	P[2] = new Audio();					
	
	Product P[] = {new Computer(), new Tv(), new Audio()};

부모배열 P[0~2]으로 컨트롤해야 됨으로 부모에 있는 변수와 메소드만 변경 사용할 수 있다.


# 객체를 다루는 배열 활용 예시.

class Product{}
class Computer extends Product{}
class buyer {
	int money = 1000;
	int bounus = 0;
	
	Product[] cart = new Product[10];
	
	int i = 0;
	
	void buy (Product p){
	
		money -= p.price; 					돈 - 상품가격    남은돈. 
		bounus += (int)(p.price/10);		상품가격/10     bonus. 
		cart[i++] = p;						cart배열에 담긴 구매된 물품.
	}
	
}


# Vector class.

Object배열을 가지고 있어서 모든 종류의 객체를 저장할 수 있다.
일반배열은 길이 조절이 안되지만, Vector class는 자동으로 배열의 길이를 조절한다. (원리는 11장에서 배움)


# 추상클래스 abstract.

추상클래스		미완성 설계도. 미완성 메소드를 갖고 있는 클래스.
			인스턴스 생성이 불가능하다. (미완성 메소드에 구현부를 작성해야 생성가능)
			다른 클래스 작성에 도움을 주기 위한 것이다.
			
추상메소드		미완성메소드. 구현부{}가 없는 메소드. ex) abstract void method();
			꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용한다.
			다른 메소드에서 호출은 가능하다. (구현이 되면 호출한 메소드를 통해 사용할 수 있다)
			
구현			추상클래스를 조상으로 하는 자식class에서 추상메소드에 구현부를 작성하는 것을 추상메소드를 '구현'한다고한다.
			추상메소드를 구현한 자식클래스에서는 인스턴스 생성이 가능하다.
			부모클래스에 여러개의 미완성메소드가 있으면 자식에서 모든 미완성메소드를 완성해줘야 인스턴스를 생성할 수 있다.
			미완성메소드가 남아 있다면 자식클래스에 class앞에 abstract를 붙인다.

ex) abstract class Player{
		abstract void play(int pos);		abstract는 구현부가 없는 메소드. 추상메소드(미완성 메소드).
	}


# 추상클래스의 간단정리.

여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 
기존클래스의 공통 부분을 뽑아서 추상클래스를 만든다.
추상클래스를 통해 다른 클래스 작성을 쉽게 할 수 있도록 도와준다.
추상클래스(부모클래스를)바꾸면 모든 자식클래스의 특성을 바꿀 수 있다. (관리가 용이하다)
쉽게 말하면 인스턴스설계도를 버전마다 저장해놓은 것이라고 생각하면된다.


# 인터페이스 interface.

인터페이스		추상메소드의 집합이다. (프로그래밍관점)
			상수, static method, default method는 부수적인 요소이다.
			구현된 것이 전혀 없는 설계도. 
			모든 멤버가 public이다.
			method에 public과 abstract를 생략할 수 있다. 항상 public이고, abstract이기 때문이다.		
			
충돌			선언부가 같고 구현부가 다른 메소드 2개를 갖고 있는 것을 충돌이라고 한다.
			
ex) interface 인터페이스이름{
		public static final 타입 상수이름 = 값;
		public abstract 메소드이름(매개변수);
}

			
# 추상클래스와 인터페이스의 차이.

추상클래스		일반클래스인데 추상메소드를 가지고 있는것.
인터페이스		대부분이 추상메소드로 이루어져있고, 일부 부가적인요소가 있는 것이다.
			인터페이스는 iv를 가질 수 없다.

공통점		추상메소드를 가지고 있다(미완성 설계도 -> 인스턴스를 만들 수 없다)


# 인터페이스의 상속.

인터페이스의 조상은 인터페이스만 가능하다. (object를 조상으로 상속받지 않는다)
다중 상속이 가능하다. (추상메소드는 충돌해도 문제 없다)

ex) interface A extends b,c { };			추상메소드 2개를 가진다.
	interface b { void method();  };		추상메소드 1개를 가진다.
	interface c { void method2(); };		추상메소드 1개를 가진다.


# 인터페이스의 구현.

인터페이스구현		인터페이스의 정의된 추상메소드를 완성하는 것.
				인터페이스를 상속받은 class에서 추상메소드를 일부만 구현하면 abstract class가 된다.
				
				
ex) class 클래스이름 implements 인터페이스이름{
		void method(){ 인터페이스구현; }
}


# 인터페이스를 이용한 다형성.

인터페이스를 구현한 클래스의 부모처럼 다형성으로 사용가능하다. 
구현클래스에서 인터페이스의 추상메소드를 불러올때 구현부를 똑같이 가져와야된다 + 생략한 publish를 붙여줘야된다.

interface Interface{
	void method(Interface i);	인터페이스에 매개변수로 interface type을 받으면 
								interface를 구현한 class만 들어올 수 있다.
}

class c implements Interface{
	Interface method(){				interface를 abstract method 앞에사용하면 반환을 구현 class로 한다는 것이다.
		Interface t = new c();		
		return t;					추상화 메소드를 구현하는 class를 리턴값으면 반환한다.
	}			
} 	

Interface i = new c();				interface안에 있는 것들만 사용가능하다.
	

# 인터페이스의 장점.

1. 두 대상(객체) 간의 연결, 대화, 소통을 돕는 중간역할을 한다.
2. 선언(설계)와 구현을 분리시킬 수 있게 한다. (변경에 유리하다)
3. 개발 시간을 단축할 수 있다. (A가 B를 의존할때 B가 완성되기 전에 interface의 추상메소드를 가져다가 쓴다)
4. 변경에 유리한 유연한 설계가 가능하다.	
5. 표준화가 가능하다. (JDBC = java와 SQL을 연결해주는 인터페이스 집합)
6. 서로 관계없는 클래스들을 관계를 맺어줄 수 있다. (다중 상속이 가능하다)

의존 		A class가 B class의 멤버를 사용하는 것을 의존한다고 말한다.




