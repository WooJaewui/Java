# Data Type의 변환방법.

문자와 숫자의 변환.

문자형과 숫자의 변환        (char)(3 + '0') = '3'       //     '3' - '0' =  3   
문자열로 변환              3 + " " = "3"               //     '3' + " " = "3"
문자열을 숫자로 변환        Integer.parseInt("3") = 3   //      Double.parseDouble("3.4") = 3.4
문자열을 문자형으로 변환    "3".CharAt(0) = '3'


# 연산자.

연산자      연산을 수행하는 기호.       ex) +, -, *, /
피연산자    연산자의 연산 수행 대상.    ex) 1, 2, 'a', "B"

모든 연산자는 연산결과를 반환한다. => 연산결과를 반환하지 않으면 연산자가 아니다.


# 연산자의 종류.

산술연산자          +, -, *, /, %, <<, >>       사칙 연산과 나머지 연산(%)
비교연산자          >, <, >=, <=, ==, !=        크고 작음과 같고 다름을 비교.
논리연산자          &&, ||, !, &, \, ^, ~       and, or으로 조건을 연결.
대입연산자          =                           우변의 값을 좌변에 저장.
기타               (type), ?:, instanceof       형변환 연산자, 삼항 연산자,instanceof연산자


# 연산자의 우선순위.

 하나의 식(expression)에 연산자가 둘 이상 있을때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것.
( )괄호를 통해 수동결정을 할 수 있다.

-x + 3                   - => +             단항 연산자가 이항 연산자보다 우선순위가 높다.
x + 3 * y                * => +             사칙연산과 규칙이 같다.
x + 3 > y - 2            +,- => >           산술연산자 > 비교연산자.
x > 3 && x < 5           >,< => &&          비교연산자 > 논리연산자.
result = x + y * 3       +, * => =          대입연산자는 우선순위가 제일 낮다.

산술 > 비교 > 논리 > 대입 순으로 우선순위를 갖는다.
단항 > 이항 > 삼항 순으로 우선순위를 갖는다.


# 연산자의 결합규칙.

우선순위가 같은 연산자가 있을때, 어떤 것을 먼저 할지.

대입, 단항      오른쪽에서 왼쪽으로 연산한다.
나머지          일반적으로 다른 연산자들은 왼쪽에서 오른쪽으로 연산한다.


# 증감연산자

증감연산자      증가연산자 + 감소연산자
증가연산자      피연산자의 값을 1 증가시킨다.        ++
감소연산자      피연산자의 값을 1 감소시킨다.        --


# 증감연산자의 특징.

전위형.       앞에붙는것.       값이 참조되기 전에 증가시킨다.        j = ++i;         ++ i;    j = i;
후위형.       뒤에붙는것.       값이 참조된 후에 증가시킨다.          j = i++;         j = i;   i++;

단독으로 사용되면 전위형 후위형의 차이가 없고, t = ++i처럼 다른 연산자와 같이 사용되면 차이가 생긴다.


# 부호연산자.

단항연산자      피연산자 1개.
부호연산자      피연산자 숫자값 앞에 부호를 나타내주는 +, -    //  +,- (단항연산자)   


# 형변환연산자.

형변환      변수 또는 상수의 type을 다른 type으로 변환하는 것. ex) double d = 85.4;
                                                               int scroe = (int)d;
                                                               int score = (int)85.4;
                                                               int score = 85;

(중요)변수 d에 저장되어 있는 85.4의 값은 변하지 않고, score에 새로 저장한 것이다.
     문자를 숫자로 바꾸거나 숫자를 문자로 바꿀때는 유니코드에 저장된 data에 의해 변환된다. ex) char(65) = 'A'

실수와정수      float에서 int로 변환할때는 소수점은 모두 버려지고, int에서 float로 변환하면 소수점은 모두 0을 붙인다.

자동형변환       compiler가 자동형변환을 해주는 경우,
                float f = 1234;같은 경우에는 float 변수에 int를 넣는 type error가 발생해야되지만 자동형변환을 해준다.
                byte b = 10; , int i = b;   int안에 byte를 넣으면 자동형변환에 의해 erorr없이 대입가능하다. 

                compiler가 자동형변환을 못하는 경우,
                int i = 3.14f;같은 경우에는 float가 int보다 변수범위가 커서 값손실이 발생할 수 있기 때문에.
                값손실 : 3.14를 3으로 표현해야 되는 경우 자동형변환은 안된다.

큰 값을 작은 변수에 넣으면 값손실에 의해 자동형변환이 안되고, 반대는 자동형변환에 의해 data type이 변경되서 대입된다.
정수형(long을 포함)은 모두 실수형으로 자동형변환이 가능하다.
수동으로 형변환을 하면 값손실이 일어나도 data type을 바꿔준다.  ex) byte b = 1000;          error가 발생한다.
                                                                byte b = (byte)1000;    b에 -24가 저장된다.


# 사칙연산자

일반적인 수학의 사칙연산자와 같고 주의해야 될 점은 같은 type에서는 결과도 같은 type으로 나타난다.

ex) int 10 / int 4 = int 2     소수점 이하는 버려진다.

다른 type에서의 계산.

결과값의 값손실이 일어날 수 있음으로 자동형변환에 의해 범위가 큰 float type으로 변형된다.
ex) int 10 / float 4.0f = float 2.5f


# 산술변환

산술변환    연산 전에 피연산자의 type을 일치시키는 것.

산술변환에 2가지 중요한 규칙!!

1. 두 피연산자의 type을 같게 일치시킨다. (더 큰 type으로 일치시킨다)

ex) long + int   =>   long + long   =>   long  ... 

2. 피연산자의 type이 int보다 작은 type이면 int로 변환된다. (연산 후의 값이 작은 type보다 클 경우가 많기 때문에)

ex) byte + short   =>   int + int   =>   int ...
    char - char    =>   int - int   =>   int ...   '2'-'0' = 2가 되는 방법. (문자형을 숫자로 바꾸는 법)


# Math class

Math.round()        실수를 소수점 첫 째자리에서 반올림한 정수를 반환.
                    ex) long result = Math.round(4.52);     5


# 나머지연산자.

%         나눗셈의 나머지를 값으로 얻는다. ex) 10%8 = 2

나머지 연산자는 0이 아닌 정수만 허용하고 부호는 무시된다. ex) 10%8 = 10%-8


# 비교연산자.

>         좌변 값이 크면, true 아니면 false.
<         좌변 값이 작으면, false 아니면 true.
>=        좌변 값이 크거나 같으면, true 아니면 false.
<=        좌변 값이 작거나 같으면, true 아니면 false.
==        두 값이 같으면, true 아니면 false.
!=        두 값이 다르면, true 아니면 false.

문자열을 비교에는 == 대신 equals()를 사용해야 된다. ex) str1.equals(str2);

'A' > 'B'  =   false          유니코드에 의해 int보다 작은 type은 int로 바뀌면서 65 > 66으로 계산된다.


# 논리연산자.

논리연산자     조건식을 연결할 때 사용하는 연산자.

||(or 결합)             피연산자 중 어느 한 쪽이 true이면 true를 결과를 얻는다.
&&(and 결합)            피연산자 양쪽 모두 true이어야 true를 결과를 얻는다.

두 개 이상의 논리연산자를 사용할때는 ()를 쳐서 순서를 명확하게 해주는 것이 좋다.

ex) 10 < x < 20 이런식의 표현은 error이다.             10 < x && x < 20
    i는 2의 배수 또는 3의 배수이다.                    i%2 == 0 || i%3 ==0.
    문자 ch는 숫자 ('0'~'9')이다.                     '0' <= ch && ch <='9'
    문자 ch는 대문자 또는 소문자이다.                  ('a' <= ch && ch <= 'z')||('A' <= ch && ch <= 'Z');


# 논리부정연산자

!         true를 false로, flase는 true로 바꾼다.
          x = true이면 !x = false , x = false이면 !x = true.
          논리부정연산자는 단항연산자이다. 오른쪽에서 왼쪽으로 계산한다.


# 조건연산자 

조건연산자 중에 삼항연사자
?:        조건식의 결과에 따라 연산결과를 달리한다. (삼항연산자)
          result = (x > y) ? x : y;     괄호 생략 가능.
                    조건식 ? 식1:식2;    조건식이 true이면 식1을 false이면 식2를 결과로 갖는다.
          if문보다 간단하게 사용할 수 있어서 사용한다.


# 대입연산자.

A = 10;        오른쪽 피연산자(rvalue)를 왼쪽 피연산자(lvalue)에 저장 후 저장된 값을 반환.
               System.out.printf(A);  =   10.
               대입연산자는 오른쪽에서 왼쪽으로 연산한다.
                
lvalue         왼쪽 피연산자이며, variable같이 저장할 수 있는 공간이다. 
               일반 literal처럼 저장공간이 아닌 것을 사용하면 error 발생.
rvalue         오른쪽 피연산자이며, literal 및 이미 저장된 variable도 사용가능하다.


# 복합대입연산자.

대입연산자와 다른 연산자를 하나로 축약해서 사용할 수 있도록 해준것.

ex) i += 3;              i = i + 3;
    i += 1;              i = i + 1;
    i *= (10 + j);       i = i * (10 + j);